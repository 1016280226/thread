# 笔记二 多线程-线程安全

[TOC]

## 1.为什么有线程安全问题

当多个线程同时共享，==**同一个全局变量或静态变量**==，做写的操作时，可能会发生数据冲突问题，也就是线程安全问题。

> 案例： 需求现在有100 张火车票，有2个窗口同抢火车票，请使用多线程模拟抢票效果。

```java
package lang.thread.security_02;

/**
 * Created by Calvin on 2019/4/13
 * 标题: 线程安全的问题
 * 模拟抢火车票
 */
public class SimulateTrainTicket_01 implements Runnable{

    /** 火车票有100 张 **/
    private int trainTicketCount = 100;

    @Override
    public void run() {
        // 只要火车票大于0，继续售票
        while (trainTicketCount > 0){
            try {
                Thread.sleep(50);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            // 售票
            saleTicket();
        }
    }

    public void saleTicket(){
        if(trainTicketCount > 0){
            if(trainTicketCount == 3){
                System.out.println(trainTicketCount);
            }
            System.out.println(Thread.currentThread().getName() + ", 出售第: " + (100 - trainTicketCount + 1) + " 票");
            trainTicketCount --;
        }
    }

    public static void main(String[] args){
        SimulateTrainTicket_01 simulateTrainTicket_01 = new SimulateTrainTicket_01();
        Thread t1 = new Thread(simulateTrainTicket_01,"窗口①号");
        Thread t2 = new Thread(simulateTrainTicket_01, "窗口②号");
        t1.start();
        t2.start();
    }
}	

############################### 运行结果 #############################################
窗口②号, 出售第: 1 票
窗口①号, 出售第: 1 票
窗口②号, 出售第: 3 票
窗口①号, 出售第: 3 票
窗口②号, 出售第: 5 票
窗口①号, 出售第: 5 票
窗口②号, 出售第: 7 票
窗口①号, 出售第: 7 票
窗口②号, 出售第: 9 票
窗口①号, 出售第: 9 票
窗口②号, 出售第: 11 票
窗口①号, 出售第: 11 票
窗口②号, 出售第: 13 票
窗口①号, 出售第: 13 票
窗口②号, 出售第: 15 票
窗口①号, 出售第: 15 票
窗口①号, 出售第: 17 票
窗口②号, 出售第: 17 票
窗口②号, 出售第: 19 票
窗口①号, 出售第: 19 票
窗口②号, 出售第: 21 票
窗口①号, 出售第: 21 票
窗口②号, 出售第: 23 票
窗口①号, 出售第: 23 票
窗口②号, 出售第: 25 票
窗口①号, 出售第: 25 票
窗口②号, 出售第: 27 票
窗口①号, 出售第: 27 票
窗口②号, 出售第: 29 票
窗口①号, 出售第: 29 票
窗口②号, 出售第: 31 票
窗口①号, 出售第: 31 票
窗口②号, 出售第: 33 票
窗口①号, 出售第: 33 票
窗口②号, 出售第: 35 票
窗口①号, 出售第: 35 票
窗口②号, 出售第: 37 票
窗口①号, 出售第: 37 票
窗口②号, 出售第: 39 票
窗口①号, 出售第: 39 票
窗口②号, 出售第: 41 票
窗口①号, 出售第: 41 票
窗口②号, 出售第: 43 票
窗口①号, 出售第: 43 票
窗口②号, 出售第: 45 票
窗口①号, 出售第: 45 票
窗口②号, 出售第: 47 票
窗口①号, 出售第: 47 票
窗口②号, 出售第: 49 票
窗口①号, 出售第: 49 票
窗口②号, 出售第: 51 票
窗口①号, 出售第: 51 票
窗口②号, 出售第: 53 票
窗口①号, 出售第: 53 票
窗口②号, 出售第: 55 票
窗口①号, 出售第: 55 票
窗口②号, 出售第: 57 票
窗口①号, 出售第: 57 票
窗口②号, 出售第: 59 票
窗口①号, 出售第: 59 票
窗口②号, 出售第: 61 票
窗口①号, 出售第: 61 票
窗口②号, 出售第: 63 票
窗口①号, 出售第: 63 票
窗口②号, 出售第: 65 票
窗口①号, 出售第: 65 票
窗口②号, 出售第: 67 票
窗口①号, 出售第: 67 票
窗口②号, 出售第: 69 票
窗口①号, 出售第: 69 票
窗口②号, 出售第: 71 票
窗口①号, 出售第: 71 票
窗口②号, 出售第: 73 票
窗口①号, 出售第: 73 票
窗口②号, 出售第: 75 票
窗口①号, 出售第: 75 票
窗口②号, 出售第: 77 票
窗口①号, 出售第: 77 票
窗口②号, 出售第: 79 票
窗口①号, 出售第: 79 票
窗口②号, 出售第: 81 票
窗口①号, 出售第: 81 票
窗口②号, 出售第: 83 票
窗口①号, 出售第: 83 票
窗口②号, 出售第: 85 票
窗口①号, 出售第: 85 票
窗口②号, 出售第: 87 票
窗口①号, 出售第: 87 票
窗口②号, 出售第: 89 票
窗口①号, 出售第: 89 票
窗口②号, 出售第: 91 票
窗口①号, 出售第: 91 票
窗口②号, 出售第: 93 票
窗口①号, 出售第: 93 票
窗口②号, 出售第: 95 票
窗口①号, 出售第: 95 票
窗口②号, 出售第: 97 票
窗口①号, 出售第: 97 票
窗口②号, 出售第: 99 票
窗口①号, 出售第: 99 票
```

**一号窗口和二号窗口同时出售火车第九九张,部分火车票会重复出售。**

**结论发现，多个线程共享同一个全局成员变量时，做写的操作可能会发生数据冲突问题。**



## 2.线程安全的解决方案

> *面试：如何解决多线程之间的线程安全问题？*

答：==使用多线程同步**Synchroized** 和 使用锁**Lock**==

> *面试：为什么使用线程同步或使用锁能解决线程安全问题呢？*

答：**==只能让当前一个线程进行执行。代码执行完成后释放锁，然后才能让其他线程进行执行。==**

答：这样的话就可以解决线程不安全问题。

> *面试：什么是多线程同步？*

答：==当多个线程共享同一个资源，不会受到其他线程的影响。==



### 2.1 同步Synchroized（内置锁）

#### 1. 什么是内置锁？

- 每一个**Java对象**都可以用作**一个实现同步的锁**。

- 线程进入同步**代码块之前自动获取到锁**，代码块**执行完成正常退出**或**代码块中抛出异常退出时会释放掉锁**

  **==内置锁为互斥锁==**，即线程A获取到锁后，线程B阻塞直到线程A释放锁，线程B才能获取到同一个锁

  

#### 2. 同步**Synchroized** 使用

- 修饰需要进行同步的**方法**（所有访问状态变量的方法都必须进行同步），**此时充当锁的对象为调用同步方法的对象**

  ```java
   /** 使用 Synchronized 在 方法上，此时充当锁的对象为调用方法的对象 **/
   public synchronized void saleTicket(){
          if(trainTicketCount > 0){
              if(trainTicketCount == 3){
                  System.out.println(trainTicketCount);
              }
              System.out.println(Thread.currentThread().getName() + ", 出售第: " + (100 - trainTicketCount + 1) + " 票");
              trainTicketCount --;
          }
   }
  
  ############################ 运行结果 ####################################
  窗口①号, 出售第: 1 票
  窗口②号, 出售第: 2 票
  窗口①号, 出售第: 3 票
  窗口②号, 出售第: 4 票
  窗口①号, 出售第: 5 票
  窗口②号, 出售第: 6 票
  窗口①号, 出售第: 7 票
  窗口②号, 出售第: 8 票
  窗口①号, 出售第: 9 票
  窗口②号, 出售第: 10 票
  窗口②号, 出售第: 11 票
  窗口①号, 出售第: 12 票
  窗口②号, 出售第: 13 票
  窗口①号, 出售第: 14 票
  窗口②号, 出售第: 15 票
  窗口①号, 出售第: 16 票
  窗口②号, 出售第: 17 票
  窗口①号, 出售第: 18 票
  窗口①号, 出售第: 19 票
  窗口②号, 出售第: 20 票
  窗口②号, 出售第: 21 票
  窗口①号, 出售第: 22 票
  窗口①号, 出售第: 23 票
  窗口②号, 出售第: 24 票
  窗口②号, 出售第: 25 票
  窗口①号, 出售第: 26 票
  窗口②号, 出售第: 27 票
  窗口①号, 出售第: 28 票
  窗口①号, 出售第: 29 票
  窗口②号, 出售第: 30 票
  窗口①号, 出售第: 31 票
  窗口②号, 出售第: 32 票
  窗口②号, 出售第: 33 票
  窗口①号, 出售第: 34 票
  窗口①号, 出售第: 35 票
  窗口②号, 出售第: 36 票
  窗口②号, 出售第: 37 票
  窗口①号, 出售第: 38 票
  窗口①号, 出售第: 39 票
  窗口②号, 出售第: 40 票
  窗口①号, 出售第: 41 票
  窗口②号, 出售第: 42 票
  窗口②号, 出售第: 43 票
  窗口①号, 出售第: 44 票
  窗口①号, 出售第: 45 票
  窗口②号, 出售第: 46 票
  窗口①号, 出售第: 47 票
  窗口②号, 出售第: 48 票
  窗口①号, 出售第: 49 票
  窗口②号, 出售第: 50 票
  窗口②号, 出售第: 51 票
  窗口①号, 出售第: 52 票
  窗口①号, 出售第: 53 票
  窗口②号, 出售第: 54 票
  窗口①号, 出售第: 55 票
  窗口②号, 出售第: 56 票
  窗口②号, 出售第: 57 票
  窗口①号, 出售第: 58 票
  窗口①号, 出售第: 59 票
  窗口②号, 出售第: 60 票
  窗口②号, 出售第: 61 票
  窗口①号, 出售第: 62 票
  窗口②号, 出售第: 63 票
  窗口①号, 出售第: 64 票
  窗口②号, 出售第: 65 票
  窗口①号, 出售第: 66 票
  窗口②号, 出售第: 67 票
  窗口①号, 出售第: 68 票
  窗口①号, 出售第: 69 票
  窗口②号, 出售第: 70 票
  窗口①号, 出售第: 71 票
  窗口②号, 出售第: 72 票
  窗口①号, 出售第: 73 票
  窗口②号, 出售第: 74 票
  窗口②号, 出售第: 75 票
  窗口①号, 出售第: 76 票
  窗口①号, 出售第: 77 票
  窗口②号, 出售第: 78 票
  窗口①号, 出售第: 79 票
  窗口②号, 出售第: 80 票
  窗口①号, 出售第: 81 票
  窗口②号, 出售第: 82 票
  窗口①号, 出售第: 83 票
  窗口②号, 出售第: 84 票
  窗口①号, 出售第: 85 票
  窗口②号, 出售第: 86 票
  窗口①号, 出售第: 87 票
  窗口②号, 出售第: 88 票
  窗口②号, 出售第: 89 票
  窗口①号, 出售第: 90 票
  窗口①号, 出售第: 91 票
  窗口②号, 出售第: 92 票
  窗口②号, 出售第: 93 票
  窗口①号, 出售第: 94 票
  窗口②号, 出售第: 95 票
  窗口①号, 出售第: 96 票
  窗口①号, 出售第: 97 票
  窗口②号, 出售第: 98 票
  窗口①号, 出售第: 99 票
  窗口②号, 出售第: 100 票
  ```

  



- **同步代码块**和直接使用synchronized修饰需要同步的方法是一样的，但是锁的粒度可以更细，**并且充当锁的对象不一定是this，也可以是其它对象**，所以使用起来更加灵活

  ```
  
  ```

  

 